<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Sentence Prototype</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; margin: 16px; }
    h1 { margin: 0 0 12px; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .list { margin-top:16px; display:grid; gap:8px; }
    .card { border:1px solid #e5e7eb; border-radius:12px; padding:12px; }
    .small { color:#666; font-size:.9rem; }
    button { padding:8px 12px; border:1px solid #e5e7eb; background:#f9fafb; border-radius:8px; cursor:pointer; }
    select, label { font-size: 1rem; }
  </style>
</head>
<body>
  <h1>Sentence Prototype</h1>

  <div class="row">
    <label>Level:
      <select id="level">
        <option value="1">1</option>
        <option value="2">2</option>
      </select>
    </label>

    <label><input type="checkbox" id="subjectMe" checked /> 主語＝私（省略可）</label>

    <button id="gen">Generate</button>
  </div>

  <div class="list" id="out"></div>

  <script type="module">
  // ローダー（パス違いに強い候補方式）
async function loadLevel(n) {
  const pad = String(n).padStart(2, "0");

  // sentence-proto.html の場所に依存せず当てに行く候補を複数用意
  const cand = [
    // sandboxes/ → ../app/data/levels/
    new URL("../app/data/levels/lv" + pad + ".json", document.baseURI).href,
    new URL("../app/data/levels/lv" + n   + ".json", document.baseURI).href,

    // sandboxes/ → ../data/levels/（もし昔の配置が残っていたら）
    new URL("../data/levels/lv" + pad + ".json", document.baseURI).href,
    new URL("../data/levels/lv" + n   + ".json", document.baseURI).href,

    // sandboxes/ の更に深さが違うケースの保険
    new URL("../../app/data/levels/lv" + pad + ".json", document.baseURI).href,
    new URL("app/data/levels/lv" + pad + ".json", document.baseURI).href,
  ];

  for (const url of cand) {
    try {
      const res = await fetch(url, { cache: "no-store" });
      if (res.ok) {
        const data = await res.json();
        console.log("[PROTO] loaded:", url, "→", Array.isArray(data) ? data.length : 0);
        return Array.isArray(data) ? data : [];
      } else {
        console.log("[PROTO] tried:", url, "status", res.status);
      }
    } catch (e) {
      console.log("[PROTO] failed:", url, e.message);
    }
  }
  return [];
}



    // 簡易ユーティリティ
    const byPos = (arr, pos) => arr.filter(x => x.pos === pos);
    const hasAny = (arr, cats) => (arr||[]).some(c => cats.includes(c));
    const appliesTo = (adj, noun) => {
      if (!adj.applies) return true; // 未指定は緩めに通す
      return hasAny(noun.class||[], adj.applies);
    };
    const choose = a => a[Math.floor(Math.random()*a.length)];
    const kanaOrOrth = x => x?.jp?.orth ?? "";

    // 助詞
    const particle = {
      obj: "を",
      dest: "に",   // or へ
    };

    // 文生成（安全なものだけ）
    function makeSentences({ nouns, verbs, adjs }, { subjectMe }) {
      const sents = [];

      // 形容詞 + 名詞
      adjs.forEach(adj => {
        nouns.forEach(n => {
          if (appliesTo(adj, n)) {
            sents.push({
              type: "adj+noun",
              jp: `${kanaOrOrth(adj)}${kanaOrOrth(n)}`,
              note: `(${adj.defs?.en ?? ""} ${n.defs?.en ?? ""})`
            });
          }
        });
      });

      // 名詞 + 動詞（フレーム判定）
      verbs.forEach(v => {
        (v.frames||[]).forEach(fr => {
          // obj 指定（食べる等）
          if (fr.obj) {
            nouns.forEach(n => {
              if (hasAny(n.class||[], fr.obj)) {
                const subj = subjectMe ? "私は" : ""; // 省略OKなら "" にできる
                sents.push({
                  type: "verb-obj",
                  jp: `${subj}${kanaOrOrth(n)}${particle.obj}${kanaOrOrth(v)}`,
                  note: `(eat ${n.defs?.en ?? ""})`
                });
              }
            });
          }
          // dest 指定（行く等）
          if (fr.dest) {
            nouns.forEach(n => {
              if (hasAny(n.class||[], fr.dest)) {
                const subj = subjectMe ? "私は" : "";
                sents.push({
                  type: "verb-dest",
                  jp: `${subj}${kanaOrOrth(n)}${particle.dest}${kanaOrOrth(v)}`,
                  note: `(go to ${n.defs?.en ?? ""})`
                });
              }
            });
          }
        });
      });

      // 重複を軽く除去
      const seen = new Set();
      return sents.filter(s => {
        const key = s.jp;
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
      });
    }

    async function run() {
      const lvl = Number(document.getElementById("level").value);
      // 現在Lv + 直近（試しに lv-1 まで読む）
      const levels = [lvl, Math.max(1, lvl-1)];
      const all = (await Promise.all(levels.map(loadLevel))).flat();

      const nouns = byPos(all, "noun");
      const verbs = byPos(all, "verb");
      const adjs  = byPos(all, "adj");

      const out = document.getElementById("out");
      out.innerHTML = "";

      const sents = makeSentences({ nouns, verbs, adjs }, { subjectMe: document.getElementById("subjectMe").checked });

      if (sents.length === 0) {
        out.innerHTML = `<div class="card">No candidates yet. Add tags (pos/class/frames/applies) to words.</div>`;
        return;
      }

      // 多すぎるのでランダム20件だけ表示
      const pick = [];
      const pool = sents.slice();
      for (let i=0; i<Math.min(20, pool.length); i++) {
        const j = Math.floor(Math.random()*pool.length);
        pick.push(pool.splice(j,1)[0]);
      }

      pick.forEach(s => {
        const div = document.createElement("div");
        div.className = "card";
        div.innerHTML = `
          <div style="font-size:1.2rem;font-weight:700;">${s.jp}</div>
          <div class="small">${s.note}</div>
        `;
        out.appendChild(div);
      });
    }

    document.getElementById("gen").addEventListener("click", run);
  </script>
</body>
</html>
